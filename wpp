#!/usr/bin/env bash
set -euo pipefail
IFS=$'\n\t'
export LANG=C.UTF-8
export LC_ALL=C.UTF-8

VERSION="2.0.6"
APP_TITLE="WPP Bot Manager"
PM2_NAME="wpp-bot"
BOT_ZIP_URL="https://github.com/MISTERVPN-MVT/Bot-Baileys-WhatsApp/raw/refs/heads/main/bot-wpp-baileys.zip"

BIN_PATH="/usr/local/bin/wpp"
APP_DIR="/opt/wpp-bot"
BOT_DIR="$APP_DIR/bot"
ZIP_PATH="$APP_DIR/bot-wpp-baileys.zip"
MARKER_FILE="$APP_DIR/.installed"

PM2_HOME_DEFAULT="/root/.pm2"
LOG_OUT="$PM2_HOME_DEFAULT/logs/${PM2_NAME}-out.log"
LOG_ERR="$PM2_HOME_DEFAULT/logs/${PM2_NAME}-error.log"

RESET=$'\e[0m'
BOLD=$'\e[1m'
DIM=$'\e[2m'

BLUE=$'\e[34m'
CYAN=$'\e[36m'
WHITE=$'\e[97m'
GREEN=$'\e[32m'
YELLOW=$'\e[33m'
RED=$'\e[31m'
ORANGE=$'\e[38;5;208m'

BG_GREEN=$'\e[42m'
BG_RED=$'\e[41m'
BG_YELLOW=$'\e[43m'

BORDER=$'\e[38;5;33m'
TITLE_BG=$'\e[48;5;19m'
INFO=$'\e[96m'
MUTED=$'\e[90m'

BG_BLUE=$'\e[44m'

WIDTH=70

BOX_TL="+"
BOX_TR="+"
BOX_BL="+"
BOX_BR="+"
BOX_H="-"
BOX_V="|"
BOX_ML="+"
BOX_MR="+"

cleanup_exit() {
  echo
  echo -e "${CYAN}Saindo...${RESET}"
  exit 0
}
trap cleanup_exit INT TERM

script_abs_path() {
  local p
  p="$(cd "$(dirname "${BASH_SOURCE[0]}")" && pwd)/$(basename "${BASH_SOURCE[0]}")"
  if command -v readlink >/dev/null 2>&1; then
    readlink -f "${BASH_SOURCE[0]}" 2>/dev/null || echo "$p"
  else
    echo "$p"
  fi
}

require_root() {
  if [[ "$(id -u)" -ne 0 ]]; then
    echo -e "${RED}${BOLD}Execute como root.${RESET}"
    echo -e "${DIM}Dica: sudo wpp${RESET}"
    exit 1
  fi
}

self_install() {
  local script_path
  script_path="$(script_abs_path)"
  [[ "$script_path" == "$BIN_PATH" ]] && return 0

  if command -v install >/dev/null 2>&1; then
    install -m 0755 "$script_path" "$BIN_PATH" 2>/dev/null || true
  else
    cp -f "$script_path" "$BIN_PATH" 2>/dev/null || true
    chmod +x "$BIN_PATH" 2>/dev/null || true
  fi
}

repeat_char() {
  local ch="$1"; local n="$2"
  printf '%*s' "$n" '' | tr ' ' "$ch"
}

strip_ansi() {
  sed -r 's/\x1B\[[0-9;]*[mK]//g'
}

visible_len() {
  local s="$1"
  printf "%s" "$s" | strip_ansi | wc -c | tr -d ' '
}

pad_right() {
  local text="$1"; local width="$2"
  local len; len="$(visible_len "$text")"
  if (( len >= width )); then
    echo "$(printf "%s" "$text" | strip_ansi | head -c "$width")"
  else
    printf "%s%*s" "$text" $((width-len)) ""
  fi
}

center_text() {
  local text="$1"; local width="$2"
  local len; len="$(visible_len "$text")"
  if (( len >= width )); then
    echo "$(printf "%s" "$text" | strip_ansi | head -c "$width")"
  else
    local left=$(((width-len)/2))
    local right=$((width-len-left))
    printf "%*s%s%*s" "$left" "" "$text" "$right" ""
  fi
}

box_line() {
  local left="$1" mid="$2" right="$3" color="$4"
  echo -e "${color}${left}$(repeat_char "${mid}" "$((WIDTH-2))")${right}${RESET}"
}

box_title() {
  local title="$1" color="$2"
  local content_width=$((WIDTH-2))
  local centered
  centered="$(center_text "$title" "$content_width")"
  echo -e "${color}${BOX_V}${RESET}${TITLE_BG}${BOLD}${WHITE}${centered}${RESET}${color}${BOX_V}${RESET}"
}

box_text() {
  local text="$1" color="$2"
  local content_width=$((WIDTH-2))
  local padded
  padded="$(pad_right "$text" "$content_width")"
  echo -e "${color}${BOX_V}${RESET}${WHITE}${padded}${RESET}${color}${BOX_V}${RESET}"
}

box_kv() {
  local k="$1" v="$2" color="$3"
  local content_width=$((WIDTH-2))
  local line
  line="${k}: ${v}"
  line="$(pad_right "$line" "$content_width")"
  echo -e "${color}${BOX_V}${RESET}${CYAN}${line}${RESET}${color}${BOX_V}${RESET}"
}

clear_screen() {
  command -v tput >/dev/null 2>&1 && tput clear || clear
}

spinner() {
  local label="$1"; shift
  local log="$APP_DIR/.wpp_last_action.log"
  mkdir -p "$APP_DIR" >/dev/null 2>&1 || true

  ("$@") >>"$log" 2>&1 &
  local pid=$!

  local frames=("*" "o" "O" "o")
  local i=0

  while kill -0 "$pid" 2>/dev/null; do
    printf "\r${CYAN}%s${RESET} ${BLUE}%s${RESET}" "$label" "${frames[$i]}"
    i=$(((i+1)%${#frames[@]}))
    sleep 0.08
  done

  wait "$pid" || return $?
  printf "\r${GREEN}%s${RESET} ${GREEN}OK${RESET}\n" "$label"
  return 0
}

pause() {
  echo
  read -r -p "${DIM}Pressione ENTER para continuar...${RESET} " _ || true
}

ask_confirm() {
  local prompt="$1"
  echo -e "${YELLOW}${BOLD}${prompt}${RESET}"
  local resp
  read -r -p "Digite 'sim' para confirmar: " resp
  [[ "$resp" =~ ^([sS][iI][mM]|[sS])$ ]]
}

get_pkg_mgr() {
  if command -v apt-get >/dev/null 2>&1; then echo "apt"; return 0; fi
  if command -v dnf >/dev/null 2>&1; then echo "dnf"; return 0; fi
  if command -v yum >/dev/null 2>&1; then echo "yum"; return 0; fi
  echo "unknown"
}

install_packages() {
  local mgr
  mgr="$(get_pkg_mgr)"

  case "$mgr" in
    apt)
      spinner "Atualizando repositorios (APT)" apt-get update -y
      spinner "Instalando pacotes base" apt-get install -y curl ca-certificates gnupg unzip git build-essential
      ;;
    dnf)
      spinner "Instalando pacotes base (DNF)" dnf install -y curl ca-certificates gnupg2 unzip git make gcc gcc-c++
      ;;
    yum)
      spinner "Instalando pacotes base (YUM)" yum install -y curl ca-certificates gnupg2 unzip git make gcc gcc-c++
      ;;
    *)
      echo -e "${RED}Gerenciador de pacotes nao suportado automaticamente.${RESET}"
      echo -e "${DIM}Instale manualmente: curl, unzip, git, build tools, Node.js e PM2.${RESET}"
      return 1
      ;;
  esac
}

node_version_major() {
  if ! command -v node >/dev/null 2>&1; then
    echo 0
    return 0
  fi
  node -v 2>/dev/null | sed 's/^v//' | awk -F. '{print $1}'
}

ensure_node() {
  local major
  major="$(node_version_major)"
  if (( major >= 18 )); then
    return 0
  fi

  echo -e "${YELLOW}Node.js nao encontrado (ou versao < 18). Vamos instalar Node.js 22 via NodeSource.${RESET}"
  case "$(get_pkg_mgr)" in
    apt)
      spinner "Configurando NodeSource (Node 22)" bash -c "curl -fsSL https://deb.nodesource.com/setup_22.x | bash -"
      spinner "Instalando Node.js" apt-get install -y nodejs
      ;;
    dnf)
      spinner "Configurando NodeSource (Node 22)" bash -c "curl -fsSL https://rpm.nodesource.com/setup_22.x | bash -"
      spinner "Instalando Node.js" dnf install -y nodejs
      ;;
    yum)
      spinner "Configurando NodeSource (Node 22)" bash -c "curl -fsSL https://rpm.nodesource.com/setup_22.x | bash -"
      spinner "Instalando Node.js" yum install -y nodejs
      ;;
    *)
      echo -e "${RED}Nao consegui instalar Node automaticamente neste sistema.${RESET}"
      return 1
      ;;
  esac
}

ensure_pm2() {
  if command -v pm2 >/dev/null 2>&1; then
    return 0
  fi
  spinner "Instalando PM2 (npm -g)" npm install -g pm2
}

pm2_configure_startup() {
  command -v pm2 >/dev/null 2>&1 || return 0
  pm2 startup systemd -u root --hp /root >/dev/null 2>&1 || true
  pm2 save >/dev/null 2>&1 || true
}

download_bot_zip() {
  mkdir -p "$APP_DIR"
  if command -v curl >/dev/null 2>&1; then
    spinner "Baixando bot (zip)" curl -fL "$BOT_ZIP_URL" -o "$ZIP_PATH"
  elif command -v wget >/dev/null 2>&1; then
    spinner "Baixando bot (zip)" wget -O "$ZIP_PATH" "$BOT_ZIP_URL"
  else
    echo -e "${RED}curl/wget nao encontrado.${RESET}"
    return 1
  fi
}

extract_bot_zip() {
  mkdir -p "$BOT_DIR"
  spinner "Extraindo bot" unzip -o "$ZIP_PATH" -d "$BOT_DIR"
}

bot_entrypoint() {
  if [[ -f "$BOT_DIR/package.json" ]]; then
    if grep -q '"start"[[:space:]]*:' "$BOT_DIR/package.json" 2>/dev/null; then
      echo "npm"
      return 0
    fi
  fi
  if [[ -f "$BOT_DIR/src/index.js" ]]; then echo "$BOT_DIR/src/index.js"; return 0; fi
  if [[ -f "$BOT_DIR/index.js" ]]; then echo "$BOT_DIR/index.js"; return 0; fi
  if [[ -f "$BOT_DIR/main.js" ]]; then echo "$BOT_DIR/main.js"; return 0; fi
  echo ""
}

install_bot_deps() {
  if [[ ! -f "$BOT_DIR/package.json" ]]; then
    echo -e "${RED}Nao encontrei package.json no bot extraido.${RESET}"
    echo -e "${DIM}Verifique o conteudo do zip e a pasta: ${BOT_DIR}${RESET}"
    return 1
  fi
  spinner "Instalando dependencias do bot (npm install)" bash -c "cd '$BOT_DIR' && npm install"
}

show_install_plan() {
  clear_screen
  box_line "$BOX_TL" "$BOX_H" "$BOX_TR" "$BLUE"
  box_text "$(center_text "$APP_TITLE v$VERSION" $((WIDTH-2)))" "$BLUE"
  box_text "$(center_text "Instalacao inicial" $((WIDTH-2)))" "$BLUE"
  box_line "$BOX_ML" "$BOX_H" "$BOX_MR" "$BLUE"

  box_text "O que sera feito:" "$BLUE"
  box_text "  * Baixar e extrair o bot (zip)" "$BLUE"
  box_text "  * Instalar dependencias do sistema" "$BLUE"
  box_text "  * Instalar Node.js (se necessario)" "$BLUE"
  box_text "  * Instalar PM2 (se necessario)" "$BLUE"
  box_text "  * npm install na pasta do bot" "$BLUE"
  box_text "  * Configurar .env" "$BLUE"
  box_line "$BOX_ML" "$BOX_H" "$BOX_MR" "$BLUE"

  local nodev npmv pm2v
  nodev="$(command -v node >/dev/null 2>&1 && node -v || echo 'nao instalado')"
  npmv="$(command -v npm >/dev/null 2>&1 && npm -v || echo 'nao instalado')"
  pm2v="$(command -v pm2 >/dev/null 2>&1 && pm2 -v || echo 'nao instalado')"

  box_kv "Node" "$nodev" "$BLUE"
  box_kv "NPM" "$npmv" "$BLUE"
  box_kv "PM2" "$pm2v" "$BLUE"
  box_kv "Destino" "$BOT_DIR" "$BLUE"
  box_line "$BOX_BL" "$BOX_H" "$BOX_BR" "$BLUE"
  echo
}

configure_env_wizard() {
  local env_file="$BOT_DIR/.env"
  mkdir -p "$BOT_DIR" >/dev/null 2>&1 || true

  if [[ -f "$env_file" ]]; then
    echo -e "${CYAN}${BOLD}.env encontrado:${RESET} ${env_file}"
    echo -e "${DIM}Voce pode manter como esta ou preencher agora pelo assistente.${RESET}"
    echo
    echo -e "${WHITE}[1]${RESET} Ja preenchi manualmente (manter)"
    echo -e "${WHITE}[2]${RESET} Preencher/Editar agora"
    echo
    read -r -p "Escolha: " ans
    if [[ "$ans" == "1" ]]; then
      return 0
    fi
  else
    : >"$env_file"
  fi

  declare -A cur
  while IFS='=' read -r k v; do
    [[ -z "${k:-}" ]] && continue
    cur["$k"]="${v:-}"
  done < <(grep -E '^[A-Z0-9_]+=' "$env_file" 2>/dev/null || true)

  local keys=(
    "PANEL_DOMAIN"
    "PANEL_TOKEN"
    "ADMIN_NUMBER"
    "BOT_NUMBER"
    "APP_LINK"
    "MP_ACCESS_TOKEN"
    "MP_WEBHOOK_URL"
    "TEST_MINUTES"
  )

  echo
  echo -e "${CYAN}${BOLD}Assistente de configuracao (.env)${RESET}"
  echo -e "${DIM}Dica: pressione ENTER para manter o valor atual.${RESET}"

  local tmp
  tmp="$(mktemp)"
  chmod 600 "$tmp" || true

  for k in "${keys[@]}"; do
    local current="${cur[$k]:-}"
    local shown="$current"

    if [[ "$k" =~ (TOKEN|ACCESS_TOKEN) ]] && [[ -n "$current" ]]; then
      local head="${current:0:4}"
      local tail="${current: -4}"
      shown="${head}****${tail}"
    fi

    echo
    echo -e "${WHITE}${BOLD}$k${RESET} ${DIM}(atual: ${shown:-vazio})${RESET}"
    read -r -p "Novo valor: " input
    if [[ -z "${input}" ]]; then
      input="$current"
    fi
    printf "%s=%s\n" "$k" "$input" >>"$tmp"
  done

  mv -f "$tmp" "$env_file"
  chmod 600 "$env_file" || true

  echo
  echo -e "${GREEN}${BOLD}.env configurado com sucesso.${RESET}"
}

first_run() {
  show_install_plan

  if ! ask_confirm "Deseja continuar com a instalacao agora?"; then
    echo -e "${RED}Instalacao cancelada.${RESET}"
    exit 0
  fi

  if ! command -v unzip >/dev/null 2>&1 || (! command -v curl >/dev/null 2>&1 && ! command -v wget >/dev/null 2>&1); then
    echo -e "${YELLOW}Algumas ferramentas basicas estao faltando (curl/wget/unzip). Vou instalar pacotes base primeiro.${RESET}"
    install_packages
  fi

  download_bot_zip
  if [[ -d "$BOT_DIR" ]]; then
    local bak="$APP_DIR/bot.backup.$(date +%Y%m%d%H%M%S)"
    spinner "Fazendo backup do bot atual" bash -c "mv '$BOT_DIR' '$bak'"
  fi
  mkdir -p "$BOT_DIR"
  extract_bot_zip

  show_install_plan
  box_line "$BOX_TL" "$BOX_H" "$BOX_TR" "$BLUE"
  box_text "Dependencias do sistema" "$BLUE"
  box_line "$BOX_ML" "$BOX_H" "$BOX_MR" "$BLUE"
  box_text "  * curl, ca-certificates, gnupg, unzip, git, build tools" "$BLUE"
  box_text "  * Node.js 22 (se necessario)" "$BLUE"
  box_text "  * PM2 (npm -g)" "$BLUE"
  box_line "$BOX_BL" "$BOX_H" "$BOX_BR" "$BLUE"
  echo

  if ! ask_confirm "Confirmar e instalar dependencias + bot?"; then
    echo -e "${RED}Instalacao cancelada (bot extraido, sem dependencias).${RESET}"
    exit 0
  fi

  install_packages
  ensure_node
  ensure_pm2
  install_bot_deps
  pm2_configure_startup

  configure_env_wizard

  touch "$MARKER_FILE"
  echo
  echo -e "${GREEN}${BOLD}Instalacao concluida.${RESET}"
  pause
}

pm2_exists() {
  command -v pm2 >/dev/null 2>&1 || return 1
  pm2 describe "$PM2_NAME" >/dev/null 2>&1
}

pm2_status_raw() {
  if ! command -v pm2 >/dev/null 2>&1; then
    echo "PM2_OFFLINE"
    return 0
  fi
  if ! pm2_exists; then
    echo "NOT_CREATED"
    return 0
  fi
  pm2 describe "$PM2_NAME" 2>/dev/null | awk -F: '/status/ {print $2; exit}' | xargs || true
}

pm2_field() {
  local field="$1"
  pm2 describe "$PM2_NAME" 2>/dev/null | awk -F: -v f="$field" '$1 ~ f {print $2; exit}' | xargs || true
}

pm2_pid() {
  command -v pm2 >/dev/null 2>&1 || { echo ""; return 0; }
  pm2 pid "$PM2_NAME" 2>/dev/null | tr -d ' ' || true
}

whatsapp_state() {
  # Determine the WhatsApp connection state based on PM2 and log contents. If the
  # underlying process is not running, always report as disconnected rather
  # than relying on stale log entries. This prevents stale "online" status from
  # persisting after the bot has been stopped via the menu.
  local out="${LOG_OUT}"
  local err="${LOG_ERR}"

  # If PM2 is not running the process, return DESCONECTADO early.
  local raw_status
  raw_status="$(pm2_status_raw)"
  if [[ "$raw_status" != "online" && "$raw_status" != "ONLINE" ]]; then
    echo "DESCONECTADO"
    return 0
  fi

  # If neither log exists yet, the state is unknown.
  if [[ ! -f "$out" && ! -f "$err" ]]; then
    echo "DESCONHECIDO"
    return 0
  fi

  # Examine the last 200 lines of both stdout and stderr to determine status.
  local tail
  tail="$(tail -n 200 "$out" "$err" 2>/dev/null || true)"

  # A line containing Own LID session created or msg:connected indicates a
  # successful connection.
  if echo "$tail" | grep -qE 'Own LID session created|"msg":"connected"'; then
    echo "CONECTADO"
    return 0
  fi
  # If a pairing code is present in the logs, we are still connecting.
  if echo "$tail" | grep -qE 'CODIGO DE PAREAMENTO|CÓDIGO DE PAREAMENTO'; then
    echo "CONECTANDO"
    return 0
  fi

  # Default to disconnected.
  echo "DESCONECTADO"
}

get_status_indicator() {
  local raw="$1"
  local wa="$2"
  
  if [[ "$wa" == "CONECTADO" ]]; then
    echo -e "${GREEN}●${RESET}"
  elif [[ "$wa" == "CONECTANDO" ]]; then
    echo -e "${ORANGE}●${RESET}"
  else
    echo -e "${RED}●${RESET}"
  fi
}

render_header() {
  box_line "$BOX_TL" "$BOX_H" "$BOX_TR" "$BORDER"
  box_title "WPP BOT MANAGER v$VERSION" "$BORDER"
  box_text "$(center_text "Next-Generation WhatsApp Bot Management System" $((WIDTH-2)))" "$BORDER"
  box_text "$(center_text "Author: MisterVPN (MISTERVPN-MVT)" $((WIDTH-2)))" "$BORDER"
  box_line "$BOX_BL" "$BOX_H" "$BOX_BR" "$BORDER"
}

render_status_panel() {
  local raw wa indicator pid
  raw="$(pm2_status_raw)"
  wa="$(whatsapp_state)"
  indicator="$(get_status_indicator "$raw" "$wa")"
  pid="$(pm2_pid)"
  [[ -z "$pid" || "$pid" == "0" ]] && pid="-"

  box_line "$BOX_TL" "$BOX_H" "$BOX_TR" "$BORDER"
  box_text " ${indicator} ${BOLD}${wa}${RESET}   ${DIM}PID:${RESET} ${pid}   ${DIM}DIR:${RESET} ${BOT_DIR}" "$BORDER"
  box_line "$BOX_BL" "$BOX_H" "$BOX_BR" "$BORDER"
}

render_menu() {
  box_line "$BOX_TL" "$BOX_H" "$BOX_TR" "$BORDER"
  box_text "$(center_text "${BOLD}MENU PRINCIPAL${RESET}" $((WIDTH-2)))" "$BORDER"
  box_line "$BOX_ML" "$BOX_H" "$BOX_MR" "$BORDER"

  box_text " ${INFO}[1]${RESET} ${WHITE}Iniciar Bot${RESET}" "$BORDER"
  box_text " ${INFO}[2]${RESET} ${WHITE}Parar Bot${RESET}" "$BORDER"
  box_text " ${INFO}[3]${RESET} ${WHITE}Reiniciar Bot${RESET}" "$BORDER"
  box_text " ${INFO}[4]${RESET} ${WHITE}Configurar .env${RESET}" "$BORDER"
  box_text " ${INFO}[5]${RESET} ${WHITE}Monitorar Logs${RESET}" "$BORDER"
  box_text " ${INFO}[6]${RESET} ${WHITE}Verificar Instalacao${RESET}" "$BORDER"
  box_text " ${INFO}[7]${RESET} ${WHITE}Atualizar Dependencias${RESET}" "$BORDER"
  box_text " ${INFO}[8]${RESET} ${WHITE}Deletar Script${RESET}" "$BORDER"
  box_text " ${RED}[0]${RESET} ${RED}Sair${RESET}" "$BORDER"

  box_line "$BOX_BL" "$BOX_H" "$BOX_BR" "$BORDER"
}

ensure_installed() {
  if [[ ! -f "$MARKER_FILE" ]]; then
    first_run
  fi
}

show_pairing_code_box() {
  local code="$1"
  echo
  box_line "$BOX_TL" "$BOX_H" "$BOX_TR" "$CYAN"
  box_text "$(center_text "CODIGO DE PAREAMENTO" $((WIDTH-2)))" "$CYAN"
  box_line "$BOX_ML" "$BOX_H" "$BOX_MR" "$CYAN"
  box_text "" "$CYAN"
  box_text "$(center_text "${BOLD}${GREEN}$code${RESET}" $((WIDTH-2)))" "$CYAN"
  box_text "" "$CYAN"
  box_line "$BOX_ML" "$BOX_H" "$BOX_MR" "$CYAN"
  box_text " Abra o WhatsApp -> Dispositivos conectados -> Conectar" "$CYAN"
  box_text " Cole/insira o codigo acima e aguarde finalizar." "$CYAN"
  box_line "$BOX_BL" "$BOX_H" "$BOX_BR" "$CYAN"
  echo
}

extract_pairing_code_from_logs() {
  local out="${LOG_OUT}"
  local err="${LOG_ERR}"
  local logs
  logs="$(tail -n 100 "$out" "$err" 2>/dev/null || true)"
  
  local code
  code="$(echo "$logs" | grep -A2 'CODIGO DE PAREAMENTO\|CÓDIGO DE PAREAMENTO' | grep -E '║[[:space:]]+[A-Z0-9]{8}[[:space:]]+║' | sed 's/.*║[[:space:]]*\([A-Z0-9]\{8\}\)[[:space:]]*║.*/\1/' | tail -n 1 || true)"
  
  if [[ -z "$code" ]]; then
    code="$(echo "$logs" | grep -oE '\b[A-Z0-9]{8}\b' | grep -v -E '^[0-9]{8}$' | grep -E '^[A-Z0-9]{8}$' | tail -n 1 || true)"
  fi
  
  echo "$code"
}

check_connected_from_logs() {
  local out="${LOG_OUT}"
  local err="${LOG_ERR}"
  local logs
  logs="$(tail -n 50 "$out" "$err" 2>/dev/null || true)"
  
  if echo "$logs" | grep -qE 'Own LID session created|"msg":"connected"'; then
    return 0
  fi
  return 1
}

start_bot() {
  ensure_installed

  command -v pm2 >/dev/null 2>&1 || {
    echo -e "${RED}PM2 nao esta instalado.${RESET}"
    pause
    return 1
  }

  local raw
  raw="$(pm2_status_raw)"

  if [[ "$raw" == "online" || "$raw" == "ONLINE" ]]; then
    echo -e "${YELLOW}O bot ja esta em execucao.${RESET}"
    pause
    return 0
  fi

  clear_screen
  echo
  echo -e "${CYAN}${BOLD}Iniciando Bot...${RESET}"
  echo

  local ep
  ep="$(bot_entrypoint)"

  : > "$LOG_OUT" 2>/dev/null || true
  : > "$LOG_ERR" 2>/dev/null || true

  if ! pm2_exists; then
    if [[ "$ep" == "npm" ]]; then
      (cd "$BOT_DIR" && pm2 start npm --name "$PM2_NAME" -- start) >/dev/null 2>&1
    elif [[ -n "$ep" ]]; then
      pm2 start "$ep" --name "$PM2_NAME" >/dev/null 2>&1
    else
      echo -e "${RED}Nao consegui detectar o entrypoint do bot.${RESET}"
      pause
      return 1
    fi
  else
    pm2 start "$PM2_NAME" >/dev/null 2>&1
  fi

  sleep 2
  pm2 save >/dev/null 2>&1 || true

  local start_ts last_code frames i
  start_ts="$(date +%s)"
  last_code=""
  frames=("." ".." "..." "...." ".....")
  i=0

  while true; do
    local now elapsed
    now="$(date +%s)"
    elapsed=$((now - start_ts))

    if (( elapsed > 300 )); then
      echo
      echo -e "${YELLOW}Tempo limite atingido. Verifique os logs.${RESET}"
      pause
      return 1
    fi

    local raw_st
    raw_st="$(pm2_status_raw)"

    if [[ "$raw_st" == "errored" || "$raw_st" == "ERRORED" ]]; then
      echo
      echo -e "${RED}O processo entrou em ERRO. Verifique os logs.${RESET}"
      pause
      return 1
    fi

    if check_connected_from_logs; then
      echo
      echo -e "${GREEN}${BOLD}Bot conectado com sucesso!${RESET}"
      pm2 save >/dev/null 2>&1 || true
      pause
      return 0
    fi

    local code
    code="$(extract_pairing_code_from_logs)"
    
    if [[ -n "$code" && ${#code} -eq 8 && "$code" != "$last_code" ]]; then
      last_code="$code"
      clear_screen
      show_pairing_code_box "$code"
    fi

    if [[ -n "$last_code" ]]; then
      printf "\r${CYAN}Aguardando conexao${frames[$i]}${RESET}     "
    else
      printf "\r${CYAN}Aguardando codigo de pareamento${frames[$i]}${RESET}     "
    fi

    i=$(((i+1)%${#frames[@]}))
    sleep 1
  done
}

stop_bot() {
  command -v pm2 >/dev/null 2>&1 || { echo -e "${RED}PM2 nao esta instalado.${RESET}"; pause; return 1; }
  if ! pm2_exists; then
    echo -e "${YELLOW}O bot ainda nao foi iniciado no PM2.${RESET}"
    pause
    return 0
  fi

  if ! ask_confirm "Confirma parar o bot?"; then
    echo -e "${DIM}Acao cancelada.${RESET}"
    pause
    return 0
  fi

  spinner "Parando bot" pm2 stop "$PM2_NAME"
  pm2 save >/dev/null 2>&1 || true
  pause
}

restart_bot() {
  command -v pm2 >/dev/null 2>&1 || { echo -e "${RED}PM2 nao esta instalado.${RESET}"; pause; return 1; }
  if ! pm2_exists; then
    echo -e "${YELLOW}O bot ainda nao foi criado no PM2. Use Iniciar.${RESET}"
    pause
    return 0
  fi

  if ! ask_confirm "Confirma reiniciar o bot?"; then
    echo -e "${DIM}Acao cancelada.${RESET}"
    pause
    return 0
  fi

  spinner "Reiniciando bot" pm2 restart "$PM2_NAME"
  pm2 save >/dev/null 2>&1 || true
  pause
}

monitor_logs() {
  command -v pm2 >/dev>null 2>&1 || { echo -e "${RED}PM2 nao esta instalado.${RESET}"; pause; return 1; }
  if ! pm2_exists; then
    echo -e "${YELLOW}O bot ainda nao foi criado no PM2.${RESET}"
    pause
    return 0
  fi

  clear_screen
  echo -e "${CYAN}${BOLD}Logs do bot (CTRL+C para voltar ao menu)${RESET}\n"
  
  trap 'return 0' INT
  pm2 logs "$PM2_NAME" 2>/dev/null || true
  trap cleanup_exit INT TERM
}

configure_env_menu() {
  configure_env_wizard
  pause
}

check_npm_updates() {
  if [[ ! -d "$BOT_DIR" ]]; then
    echo -e "${RED}Diretorio do bot nao encontrado.${RESET}"
    pause
    return 1
  fi

  if [[ ! -f "$BOT_DIR/package.json" ]]; then
    echo -e "${RED}package.json nao encontrado.${RESET}"
    pause
    return 1
  fi

  clear_screen
  echo -e "${CYAN}${BOLD}Verificando atualizacoes de dependencias...${RESET}"
  echo

  cd "$BOT_DIR" || return 1

  # Capture outdated dependencies. Use a parseable format so we can neatly
  # display the results. The --long and --parseable flags output lines in the
  # following colon-separated format:
  #   <name>:<current>:<wanted>:<latest>:<type>:<location>
  local outdated
  outdated="$(npm outdated --long --parseable 2>/dev/null || true)"

  # If no packages are outdated, inform the user and return.
  if [[ -z "$outdated" ]]; then
    echo -e "${GREEN}Todas as dependencias estao atualizadas!${RESET}"
    pause
    return 0
  fi

  # Build a pretty table-like view using the existing box drawing functions. We
  # construct a header and then iterate through each outdated line, splitting
  # on colons. This makes it easier to identify which packages need updating
  # and to which versions.
  box_line "$BOX_TL" "$BOX_H" "$BOX_TR" "$BLUE"
  box_text "Dependencias desatualizadas" "$BLUE"
  box_line "$BOX_ML" "$BOX_H" "$BOX_MR" "$BLUE"
  box_text "   Pacote           Atual   Desejado  Mais Recente " "$BLUE"
  box_line "$BOX_ML" "$BOX_H" "$BOX_MR" "$BLUE"
  while IFS= read -r line; do
    [[ -z "$line" ]] && continue
    IFS=':' read -r pkg cur want latest type loc <<< "$line"
    local name_fmt
    name_fmt="$(printf "%-15.15s" "$pkg")"
    local cur_fmt
    cur_fmt="$(printf "%-7.7s" "$cur")"
    local want_fmt
    want_fmt="$(printf "%-9.9s" "$want")"
    local latest_fmt
    latest_fmt="$(printf "%-11.11s" "$latest")"
    box_text "   ${CYAN}${name_fmt}${RESET} ${YELLOW}${cur_fmt}${RESET} ${GREEN}${want_fmt}${RESET} ${GREEN}${latest_fmt}${RESET} " "$BLUE"
  done <<< "$outdated"
  box_line "$BOX_BL" "$BOX_H" "$BOX_BR" "$BLUE"
  echo

  if ask_confirm "Deseja atualizar todas as dependencias?"; then
    echo
    spinner "Atualizando dependencias" npm update
    echo
    echo -e "${GREEN}${BOLD}Dependencias atualizadas com sucesso!${RESET}"

    if pm2_exists; then
      echo
      if ask_confirm "Deseja reiniciar o bot para aplicar as atualizacoes?"; then
        spinner "Reiniciando bot" pm2 restart "$PM2_NAME"
        pm2 save >/dev/null 2>&1 || true
      fi
    fi
  else
    echo -e "${DIM}Atualizacao cancelada.${RESET}"
  fi

  pause
}

delete_script() {
  clear_screen
  echo -e "${RED}${BOLD}ATENCAO: Esta acao ira remover o script e todos os arquivos do bot.${RESET}"
  echo -e "${DIM}Isso inclui o diretorio ${BOT_DIR}, o arquivo ${BIN_PATH} e o processo PM2.${RESET}"
  echo
  if ! ask_confirm "Deseja realmente continuar e excluir tudo?"; then
    echo -e "${DIM}Remocao cancelada.${RESET}"
    pause
    return 0
  fi

  if pm2_exists; then
    echo
    spinner "Parando bot" pm2 stop "$PM2_NAME"
    spinner "Removendo bot do PM2" pm2 delete "$PM2_NAME"
    pm2 save >/dev/null 2>&1 || true
  fi

  if [[ -d "$APP_DIR" ]]; then
    spinner "Removendo diretorio do bot" rm -rf "$APP_DIR"
  fi

  if [[ -f "$BIN_PATH" ]]; then
    spinner "Removendo script" rm -f "$BIN_PATH"
  fi

  echo
  echo -e "${GREEN}${BOLD}Script removido com sucesso.${RESET}"
  echo -e "${DIM}Fechando...${RESET}"
  exit 0
}

verify_installations() {
  clear_screen
  render_header
  echo

  box_line "$BOX_TL" "$BOX_H" "$BOX_TR" "$BLUE"
  box_text "$(center_text "VERIFICACAO" $((WIDTH-2)))" "$BLUE"
  box_line "$BOX_ML" "$BOX_H" "$BOX_MR" "$BLUE"
  box_kv "Node" "$(command -v node >/dev/null 2>&1 && node -v || echo 'nao instalado')" "$BLUE"
  box_kv "NPM" "$(command -v npm >/dev/null 2>&1 && npm -v || echo 'nao instalado')" "$BLUE"
  box_kv "PM2" "$(command -v pm2 >/dev/null 2>&1 && pm2 -v || echo 'nao instalado')" "$BLUE"
  box_kv "Bot" "$( [[ -d "$BOT_DIR" ]] && echo 'encontrado' || echo 'nao encontrado' )" "$BLUE"
  box_kv ".env" "$( [[ -f "$BOT_DIR/.env" ]] && echo 'encontrado' || echo 'nao encontrado' )" "$BLUE"
  box_kv "Marker" "$( [[ -f "$MARKER_FILE" ]] && echo 'ok' || echo 'nao instalado' )" "$BLUE"
  box_line "$BOX_BL" "$BOX_H" "$BOX_BR" "$BLUE"

  echo
  echo -e "${DIM}Ultimo log de acao: ${APP_DIR}/.wpp_last_action.log${RESET}"
  pause
}

menu_loop() {
  while true; do
    clear_screen
    render_header
    echo
    render_status_panel
    echo
    render_menu
    echo
    echo -ne "${BORDER}${BOLD}Selecione uma opcao [0-8]: ${RESET}"

    local key=""
    read -rsn1 key || true
    echo

    case "$key" in
      1) start_bot ;;
      2) stop_bot ;;
      3) restart_bot ;;
      4) configure_env_menu ;;
      5) monitor_logs ;;
      6) verify_installations ;;
      7) check_npm_updates ;;
      8) delete_script ;;
      0) echo -e "${CYAN}Saindo...${RESET}"; exit 0 ;;
      *)
        echo -e "${YELLOW}Opcao invalida.${RESET}"
        sleep 0.5
        ;;
    esac
  done
}

main() {
  require_root
  self_install || true

  if [[ ! -f "$MARKER_FILE" ]]; then
    first_run
  fi

  menu_loop
}

main "$@"
